{ The image editor component of the gedit program.
   It does not interact directly with pgs or gpack, rather it just edits
   an image that is currently on screen

   There will be an option to import both gfx and vga (old qbasic files)
   Also export the gfx files.

   The VGA back buffer will be a scratch space to store working data or to
   save the working screen while UI elements are active.
   A Danson 2025 }

unit imgedit;

interface

{ edit an image - this presumes that it is currently drawn on screen }
{ returns true if user chooses to save changes }
function editImg(sizex, sizey : word):boolean;
{clears undo buffer}
procedure clearUndo;
{import a gfx file - these are the files generated by the old gedit}
procedure importGFX;
{ export a GFX file }
procedure exportGFX;
{get the size of the current image}
procedure getSize(var sizex, sizey : word);

implementation

uses commonui, vga, bfont, buffer, keybrd, gcommon, help;

var
   sx, sy   : word; {the size of the image we are currently editing }
   cc	    : byte; {the current colour we're drawing with - an index into the drawing palette array }
   pal	    : array[0..9] of byte; { the drawing palette - a set of colours you can choose from to aid in image editing. }
   pc	    : byte; { the colour of the current pixel behind the cursor }
   x,y	    : word; { the cursor location }
   undo	    : array[0..39] of pointer; {pointer to undo image}
   undoSize : array[0..39] of word;    {size of the undo image - 0 means no image.}
   undoPos  : integer; {the current undo image}
   tool	    : byte; {current tool selected 0 - point 1 - line 2 - circle 3 - fill}
   contdraw : boolean; {continuous drawing for pixel tool }
   lnx,lny  : word; {co-ordinate for line drawing - x is set to $FFFF if first co-ordinate has not been selected}

const
   toolName: array[1..5] of string[10] = ('Pixel', 'Line', 'Circle', 'Fill', 'Text');

{get the size of the current image}
procedure getSize(var sizex, sizey : word);
begin
   sizex:=sx;
   sizey:=sy;
end;

{clears undo buffer}
procedure clearUndo;
begin
   for undoPos:= 0 to 39 do
      if undoSize[undoPos] > 0 then
      begin
	 freemem(undo[undoPos], undoSize[undoPos]);
	 undoSize[undoPos] := 0;
      end;
end;

procedure drawCurrentTool;
var
   s : string;
begin
   s:= toolName[tool];
   if ((tool=1) or (tool=2)) then
      if contdraw then
	 s:= 'Continuous ' + s;
   filledBox(187,190,319,199,0);
   textxy(187,190,4,9,s);	 
end;

{ updates the current palette display on screen }
procedure drawPal;
var
   i : byte;
begin
   {clear the area where it is drawn}
   filledbox(300,0,319,110,0);

   {draw the colours }
   for i:= 0 to 9 do
   begin
      filledbox(309, i*10, 319, (i+1)*10, pal[i]);
   end;

   {draw a line to indicate which entry is currently in use}
   line(300, (cc*10) + 5, 308, (cc*10) + 5, 9);   
end;

{adds an image to the undo buffer}
procedure refreshUndo;
var
   pos : byte;
begin
   putpixel(x,y,pc);
   
   inc(undoPos); { move to next position }
   undoPos := undoPos mod 40; {make sure we don't exceed the array bounds}
   
   if undoSize[undoPos]>0 then freemem(undo[undoPos], undoSize[undoPos]); {free memory if needed}

   {get new undo img}
   undoSize[undoPos] := imageSize(sx,sy);
   {check we have enough memory}
   if undoSize[undoPos] > maxavail then
   begin {we need to free the oldest image!}
      pos:= undoPos;
      while ((undoSize[pos] > 0) and (pos <> undoPos)) do
      begin
	 dec(pos);
	 if pos>39 then pos:=39;
      end;
      {pos will be at the start - it's the slot available before the begining of the buffer }
      {move forward to where the first item should be}
      pos := (pos+1) mod 40; {this will wrap around if needed}
      {free the slot as long as it has data in it.}
      if undoSize[pos] > 0 then
      begin
	 freemem(undo[pos],undoSize[pos]);
	 undoSize[pos] := 0;
      end;
   end;
   
   getmem(undo[undoPos], undoSize[undoPos]);
   getImage(0,0,sx-1,sy-1, undo[undoPos]);
end;

{replaces current image with last image in undo buffer}
procedure useUndo;
begin
   if undoSize[undoPos] = 0 then exit; {exit if there is no image}

   filledBox(0,0,sx,sy,0);

   putimage(0,0,undo[undoPos]);

   { restore image size in case it changed the size  - stored in the image }
   sx := memw[seg(undo[undoPos]^) : ofs(undo[undoPos]^) ];
   sy := memw[seg(undo[undoPos]^) : ofs(undo[undoPos]^) + 2 ];

   {free the current image and mark the position as empty}
   freemem(undo[undoPos],undoSize[undoPos]);
   undoSize[undoPos] := 0;

   {move to previous image in undo buffer}
   dec(undoPos);
   if undoPos < 0 then undoPos:= 39;

   pc := getPixel(x,y);
end;

{copies an image from one location to another}
procedure copyImg(srcx, srcy, szx, szy, dx, dy : word);
var
   img	   : pointer;
   imgSize : word;
begin
   imgSize := imageSize(szx,szy);
   getmem(img, imgSize);
   getImage(srcx,srcy, szx-1, szy-1, img);
   putImage(dx, dy, img);
   freemem(img, imgsize);
end;
					       

procedure double;
var i,c,z,w,a : integer;
begin
   if ((sx>140) or (sy>100)) then exit;

   refreshUndo;

   {use the back buffer as scratch space}
   copyToBuffer; {copy the screen to the backbuffer}
   if not(setDrawMode(1)) then exit;

   copyImg(0,0,sx,sy, sx + 10,0);
   
   putpixel(x,y,pc);
   for i:= 0 to sx-1 do
      for c:= 0 to sy-1 do
      begin
	 z:=(i*2);
	 w:=(c*2);
	 a:= getpixel((sx+10)+i,c);
	 putpixel(z,w,a);
	 putpixel(z+1,w,a);
	 putpixel(z,w+1,a);
	 putpixel(z+1,w+1,a);
      end;
   sx:=sx*2;
   sy:=sy*2;  

   {switch back to the screen an update the image}
   if setDrawMode(2) then copySegment(0,0,sx,sy,false);

   {update the stored colour for the cursor}
   pc:= getpixel(x,y);
end; { double }

procedure mirror;
var i,c,p : byte;
begin
   if sx>150 then exit; { we don't have room to work on an image bigger than this }
   refreshUndo;

   {use the back buffer as scratch space}
   copyToBuffer; {copy the screen to the backbuffer}
   if not(setDrawMode(1)) then exit;

   copyImg(0,0,sx,sy, sx + 10,0);
   
   putpixel(x,y,pc);
   for i:= 0 to sx-1 do
      for c:= 0 to sy-1 do
	 begin
	    p := getpixel((2*sx)+9 - i,c);
	    putpixel(i,c,p);
	 end;

   {set the draw mode and update the image}
   if setDrawMode(2) then copySegment(0,0,sx,sy, false);
   
   pc:= getpixel(x,y);
end;

procedure rotate;
var
   i,c,p : byte;
   
begin
   if sx > 150 then exit; { we don't have room to work on an image bigger than this!}
   refreshUndo;

   {use the back buffer as scratch space}
   copyToBuffer; {copy the screen to the backbuffer}
   if not(setDrawMode(1)) then exit;

   copyImg(0,0,sx,sy, sx + 10,0);

   putpixel(x,y,pc);
   for i:= 0 to sy-1 do
      for c:= 0 to sx-1 do
	 begin
	    p := getpixel((2*sx)+9 - c,i);
	    putpixel(i,c,p);
	 end;

   swapW(sx,sy);
   
   {set the draw mode and update the image}
   if setDrawMode(2) then copySegment(0,0,sx,sy, false);
   
   pc:= getpixel(x,y);
end;

{import a 10x10 image from my previous QBasic work}
procedure importVGA;
var
   f	     : string;
   inf	     : reader;
   i,c	     : byte;
   s	     : string;
   col, code : integer;
begin
   refreshUndo;
   f := fileSelector('vga', false);
   if f='' then exit;
   inf.open(f);
   for c:= 0 to 9 do
      for i:= 0 to 9 do
      begin
	 s:=inf.readln;
	 val(s,col,code);
	 putpixel(i,c,col);
      end;   
   inf.close;
   sx:=10;
   sy:=10;
   pc := getpixel(x,y);   
end;

{import a gfx file - these are the files generated by the old gedit}
procedure importGFX;
var
   f	 : string;
   b	 : reader;
   c	 : char;
   cx,cy : byte;
begin
   refreshUndo;
   f := fileSelector('gfx',false);
   if f='' then exit;
   b.open(f);
   sx := ord(b.readchar);
   sy := ord(b.readchar);
   for cy := 0 to sy-1 do
      for cx := 0 to sx-1 do
	 putpixel(cx,cy,ord(b.readchar));
   b.close;
   pc := getpixel(x,y);   
end;

{import a file - either gfx or vga formats}
procedure import;
var
   m : menudata;
   s : byte;
begin
   m.title := 'Load Image file type';
   m.items[1] := 'GFX files';
   m.items[2] := 'VGA files (QBasic)';
   m.count := 2;
   s:= menu(m);

   {act on selection}
   if s=1 then importGFX;
   if s=2 then importVGA;
   {otherwise do nothing}
end;

procedure exportGFX;
var
   f	 : string;
   w	 : writer;
   cx,cy : word;
begin
   f:= fileSelector('gfx',true);
   if f = '' then exit;
   putpixel(x,y,pc);
   w.open(f);
   w.writeChar(chr(sx));
   w.writeChar(chr(sy));
   for cy:= 0 to sy-1 do
      for cx := 0 to sx-1 do
	 w.writechar(chr(getpixel(cx,cy)));
   w.close;
end;

procedure recursiveFill(cx,cy : integer; dc, cr: byte; depth:word);
var dx	 : integer; {delta x}
   stx,enx : integer; {start and end of a row}
   c	 : byte;
   done	 : boolean;
begin
   {check we haven't gone too deep}
   if depth>2000 then exit;
   {check we are still in bounds}
   if cx<0 then exit;
   if cy<0 then exit;
   if cx>sx-1 then exit;
   if cy>sy-1 then exit;
   {check the current pixel is the colour we are replacing}
   if getpixel(cx,cy) <> cr then exit;
   {check if the current pixel is already the draw colour}
   if getPixel(cx,cy) = dc then exit;
   {ok we have done the base checks we can replace the current pixel}
   putpixel(cx,cy,dc);

   {fill out the entire row to the left}
   done:=false;
   dx := 1;
   stx:=cx;
   while ((cx - dx>-1) and not(done)) do
   begin
      c := getPixel(cx - dx,cy);
      if ((c <> cr) or (c=dc)) then
	 done:= true
      else
      begin
	 putpixel(cx-dx,cy,dc);
	 stx := cx-dx;
	 inc(dx);
      end;
   end;

   {fill out the entire row to the right}
   done:=false;
   dx := 1;
   enx := cx;
   while ((cx + dx < sx) and not(done)) do
   begin
      c := getPixel(cx + dx,cy);
      if ((c <> cr) or (c=dc)) then
	 done:= true
      else
      begin
	 putpixel(cx+dx,cy,dc);
	 enx := cx + dx;
	 inc(dx);
      end;
   end;

   for dx := stx to enx do
   begin
	 {recursively check neighboring pixels}
	 recursiveFill(dx,cy-1,dc,cr, depth+1);
	 recursiveFill(dx,cy+1,dc,cr, depth+1);
   end;
end;

procedure randomFill;
var
   col	 : array[0..9] of byte;
   count : word;
   cx,cy : word;
   done	 : boolean;
   c	 : char;
begin
   randomize;
   {prepare by refreshing undo }
   refreshUndo;
   {this section will pick colours from the palette to use for the randomiser}
   copyToBuffer;
   textxy(210,105,4,9,'Select Colours');
   textxy(210,113,4,9,'for random fill');
   done := false;
   count := 0;
   while not(done) do
   begin
      drawPal;
      while not(keypressed) do;
      c:= readkey;
      if ((c='p') or (c='P')) then
      begin
	 copyToScreen;
	 pal[cc] := pickColor;
	 for cx := 0 to count do
	    filledbox(290, count*10, 300, (count+1)*10, col[count]);
      end;
      if c= chr(27) then done:= true; {escape pressed - finished picking colours}
      if c = chr(13) then {enter pressed - pick a colour}
      begin
	 col[count] := pal[cc];
	 if (count=9) then done:=true;
	 filledbox(290, count*10, 300, (count+1)*10, col[count]);
	 inc(count);
      end;
      {check for arrow keys}
      if c=chr(0) then
      begin
	 c:= readkey;
	 if ((c=chr(72)) and (cc>0)) then dec(cc);
	 if ((c=chr(80)) and (cc<9)) then inc(cc);
      end;      
   end;

   copyToScreen;
   {interactive part done - lets generate the random noise}
   for cy:= 0 to sy-1 do
      for cx := 0 to sx-1 do
	 putpixel(cx,cy,col[random(count)]);
   pc:= getpixel(x,y);
end;

procedure circle;
var radius : word;
   c	   : char;
   done	   : boolean;
begin
   {make undo...}
   refreshUndo;
   copyToBuffer;
   radius := 10;
   done:= false;

   while (not(done)) do
   begin
      {refresh display }
      copySegment(0,0,sx,sy, false);
      vga.circle(x,y,radius, pal[cc]);

      while not(keypressed) do;

      c:= readkey;

      if c = chr(27) then
      begin
	 {escape pressed}
	 copyToScreen; {undo any drawing}
	 done:= true;
      end;
      if c=chr(13) then done:=true; { enter pressed - stick with the what is on screen }
      if c=chr(0) then
      begin
	 c := readkey;
	 if ((c=chr(72)) and (radius>4)) then dec(radius);
	 if ((c=chr(80)) and (radius<200)) then inc(radius);
      end;
   end;
end;

procedure imageInfo;
var
   s,t	   : string;
   c	   : char;
   i,count : byte;
   
begin
   copyToBuffer;

   filledbox(70,0,250,199,0);
   line(70,0,70,199,7);
   line(250,0,250,199,7);

   str(sx,s);
   t:= 'Image size: '+s+' x ';
   str(sy,s);
   t:= t + s;
   textxy(80,20,4,9,t);
   
   t:='Available memory :';
   str(memavail,s);
   t:= t +s;
   textxy(80,40,4,9,t);

   t:='Largest block :';
   str(maxavail,s);
   t:=t+s;
   textxy(80,50,4,9,t);

   count:=0;
   for i:= 0 to 39 do
      if undoSize[i]>0 then inc(count);

   t:= 'Undo buffer :';
   str(count,s);
   t:=t+s;
   textxy(80,70,4,9,t);

   while not(keypressed) do;

   c:= readkey;
   if c = chr(0) then c:= readkey;

   copyToScreen;
end;

{ a menu for activating special functions such as random fill, import/export etc}
procedure specialFunctionMenu;
var
   m : menudata;
   r : byte;
begin
   m.title := 'Choose a function';
   m.items[1]:= 'Import';
   m.items[2]:= 'Export';
   m.items[3]:= 'Rotate';
   m.items[4]:= 'Vertical Mirror';
   m.items[5]:= 'Double Size';
   m.items[6]:= 'Randomise';
   m.items[7]:= 'Image info';
   m.count:=7;
   r := menu(m);

   case r of
     1 : import;
     2 : exportGFX;
     3 : rotate;
     4 : mirror;
     5 : double;
     6 : randomFill;
     7 : imageInfo;
   end;   
end;

procedure selectTool;
var
   m : menudata;
   r : byte;
begin
   m.title := 'Select tool';
   for r := 1 to 5 do
      m.items[r] := toolName[r];
   m.count := r;

   r:= menu(m);
   if r=0 then exit;
   tool := r;
   drawCurrentTool;
end;

procedure useTool;
var
   s : string;
begin
   case tool of
     1 : begin
	    pc := pal[cc];
	    putpixel(x,y,pal[cc]);
	 end;
     2 : begin
	    if (lnx=$FFFF) then
	    begin
	       lnx := x;
	       lny := y;
	    end
	    else
	    begin
	       refreshUndo;
	       line(lnx,lny,x,y,pal[cc]);
	       lnx:= $FFFF;
	       if contdraw then
	       begin
		  lnx:=x;
		  lny:=y;
	       end;
	    end;
	 end;
     3 : circle;
     4 : begin
	    refreshUndo;
	    recursiveFill(x,y,pal[cc],getpixel(x,y),1);
	 end;
     5 : begin
	    refreshUndo;
	    copyToBuffer;
	    textxy(0,170,4,9,'Enter Text');
	    s := ginput(0,180);
	    copyToScreen;
	    textxy(x,y,4,pal[cc],s);
	 end;
   end;	
end;

procedure extendedKeys;
var
   c : char;
begin
   c:= readkey;
   case c of
     chr(72) : if y>0 then dec(y);
     chr(80) : if y<sy-1 then inc(y);
     chr(75) : if x>0 then dec(x);
     chr(77) : if x<sx-1 then inc(x);
     chr(59) : imgHelp;
     chr(60) : specialFunctionMenu;
     chr(61) : selectTool;
   end;
end;

{ edit an image - this presumes that it is currently drawn on screen }
{ This is where the main loop of the image editor resides. }
{returns true is user chose to save changes }
function editImg(sizex, sizey : word):boolean;
var
   c	: char;
   done	: boolean;
   r	: byte;
begin
   {default is to assume the image will be saved - just in case}
   editImg := true;

   {set up initial values for start position and tools}
   x:=0; y:=0;
   pc := getPixel(0,0);
   lnx := $FFFF;
   tool := 1;
   contdraw:=false;
   sx := sizex;
   sy := sizey;

   {draw the palette}
   drawPal;
   drawCurrentTool;
   done:=false;

   {load the undo buffer with the starting image}
   refreshUndo;

   { main loop }
   while not(done) do
   begin
      while not(keypressed) do;
      putPixel(x,y,pc);

      c:= readkey;
      c:= upcase(c);

      case c of
	{ arrow keys and other extended keys}
	chr(0)  : extendedKeys;
	{special functions}
	'U'     : useUndo;
	'M'     : refreshUndo; {manually add state to undo}
	' '     : useTool;
       
	{Palette and colour selection}
	'1'	: cc := 0;
	'2'	: cc := 1;
	'3'	: cc := 2;
	'4'	: cc := 3;
	'5'	: cc := 4;
	'6'	: cc := 5;
	'7'	: cc := 6;
	'8'	: cc := 7;
	'9'	: cc := 8;
	'0'	: cc := 9;
	'P'	: pal[cc] := pickColor;
	','	: if cc>0 then dec(cc);
	'.'     : if cc<9 then inc(cc);
	'G'	: pal[cc] := pc;

	chr(13)	: begin
	   contdraw:= not(contdraw);
	   drawCurrentTool;
	end;
	{Quit options}
	chr(27),'Q' : begin
	   r:= exitMenu;
	   {option 0 does nothing! continue!}
	   if r= 1 then
	   begin
	      {save and exit!}
	      editImg := true; {just in case}
	      done:= true;
	   end;
	   if r= 2 then
	   begin
	      {discard and exit!}
	      editImg := false; 
	      done:= true;
	   end;
	end;
	
      end;
      
      pc:= getPixel(x,y);
      if ((tool=1) and contdraw) then pc := pal[cc];
      
      putPixel(x,y,15 xor pc);
      line(sx,0,sx,sy,7);
      line(0,sy,sx,sy,7);
      drawPal;
   end;
   putPixel(x,y,pc);
   
   {we're done we need to clean-up }
   { clear the undo buffer so that memory is freed correctly and there isn't contamination
    with the next image edited }
   clearUndo;
end;

    

begin
   sx:=10;
   sy:=10;
   contdraw:= false;
   for cc := 0 to 9 do
      pal[cc] := cc;
   cc := 0;
   for undoPos := 0 to 39 do
      undoSize[undoPos] := 0;
   undoPos := 0;
end.
